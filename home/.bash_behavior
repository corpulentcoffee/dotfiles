# shellcheck shell=bash
# This is sourced from `.bash_aliases` under interactive bash; see notes there.

# Interactive mode for incomplete `aws` commands (like `aws --cli-auto-prompt`).
# In contrast to using Bash completion, incomplete commands that trigger the AWS
# CLI interactive mode are added to Bash Readline history whereas the finalized
# commands are added to the Readline history inside the interactive mode itself,
# which can be seen via `jq .commands ~/.aws/cli/cache/prompt_history.json`.
export AWS_CLI_AUTO_PROMPT=on-partial

export EDITOR=vi # safe fallback, even on BusyBox systems
if command -v vim &>/dev/null; then
  EDITOR=vim
fi

# Increase bash history size.
HISTSIZE=100000
HISTFILESIZE=500000

# Improve `less` paging. In `git` operations, `FRX` (`--quit-if-one-screen`,
# `--RAW-CONTROL-CHARS`, and `--no-init`) is exported if `LESS` is not set (see
# notes for `core.pager` on `man git-config`).
__ccdotfiles_less=(
  --chop-long-lines # must scroll horizontally to see remainder of long lines
  --ignore-case     # can use uppercase in pattern for a case-sensitive search
  --LONG-PROMPT     # see visible line numbers and, if known, total line count
  # --mouse         # scrollwheel under `--no-init`, but breaks text selection
  # --no-init       # do not clear screen before and after pager usage
  --quit-if-one-screen
  --RAW-CONTROL-CHARS
)
export LESS="${__ccdotfiles_less[*]}"
unset __ccdotfiles_less

# Avail `nvm` and automatically activate Node environment as given by `.nvmrc`
# files. `NVM_DIR` can be specified explicitly elsewhere, like machine-specific
# not-version-controlled `~/.profile` file to make it visible higher in process
# tree (e.g. to desktop environment apps), but elsewise will be automatically
# detected and set here if nvm is in the normal place. Under GitHub Codespaces,
# `nvm` is already available and installed to `~/.nvm`, and NVS is the preferred
# way of doing things anyway, so just skip this setup if running in Codespaces.
if [[ ! -v CODESPACES ]]; then
  if [[ ! -v NVM_DIR && -d ~/.nvm && -f ~/.nvm/nvm.sh ]]; then
    export NVM_DIR=~/.nvm
  fi
  if [[ -v NVM_DIR && -d "$NVM_DIR" && -f "$NVM_DIR/nvm.sh" ]]; then
    # `--no-use` avoids delay of activating `default` environment for new shells.
    # shellcheck source=/dev/null
    source "$NVM_DIR/nvm.sh" --no-use &&

      # Explicitly call `nvm use` when `.nvmrc` is present or version it has
      # changes (due to, e.g., changing directories, moving git `HEAD`, altering
      # contents manually). Calling `nvm use` explicitly also prints activated
      # environment and triggering `.nvmrc`. This is one of *many* ways to do
      # this; see <https://github.com/nvm-sh/nvm#deeper-shell-integration>.
      function __ccdotfiles_promptCommandNvmrc {
        local nvmrc
        nvmrc=$(nvm_find_nvmrc)

        local version
        [ -n "$nvmrc" ] && version=$(<"$nvmrc")

        if [ -n "$version" ]; then
          if [ "$version" != "$__ccdotfiles_promptCommandNvmrc_last" ]; then
            nvm use
            __ccdotfiles_promptCommandNvmrc_last=$version
          fi
        elif [ -n "$__ccdotfiles_promptCommandNvmrc_last" ]; then
          nvm deactivate
          unset __ccdotfiles_promptCommandNvmrc_last
        fi
      } &&
        PROMPT_COMMAND="__ccdotfiles_promptCommandNvmrc; $PROMPT_COMMAND"
  fi
fi

# Given a regular bash prompt ending in '$ ' that doesn't already try to do
# something git-related, if we have `__git_ps1` *or* it appears that we *will*
# have it (as on Ubuntu, where `/etc/bash_completion.d/git-prompt` sources
# `/usr/lib/git-core/git-sh-prompt`, which happens later after we're done here),
# call out to include git info in the prompt whenever in a repository and also
# change the appearance of the trailing '$ ' to differentiate from the git info.
# Some environments, like Codespaces, will provide their own fancy `PS1`.
if [[ $PS1 == *'\$ ' && $PS1 != *'git'* ]] &&
  (
    command -v __git_ps1 &>/dev/null ||
      [ -f /etc/bash_completion.d/git-prompt ] && [ -f /usr/lib/git-core/git-sh-prompt ]
  ); then
  function __ccdotfiles_ps1Git {
    if command -v __git_ps1 &>/dev/null; then
      GIT_PS1_SHOWDIRTYSTATE=1 GIT_PS1_SHOWSTASHSTATE=1 \
        GIT_PS1_SHOWUNTRACKEDFILES=1 GIT_PS1_SHOWUPSTREAM=auto __git_ps1 ' %s'
    fi
  }
  PS1=${PS1/%'\$ '/'\[\e[1;33m\]'\$(__ccdotfiles_ps1Git)'\[\e[3;37m\]\$\[\e[0m\] '}
fi

# Print exit code after each command. This checks `$?`, so it needs to be first
# in `$PROMPT_COMMAND`, thus try to define this as late as possible during shell
# setup. Avoid writing newlines here to be friendly to pagers, e.g.: `less` with
# `--quit-if-one-screen` assumes prompt that follows won't be multiline, and
# similarly, if using `--no-init` to avoid clearing the screen, the first line
# of on-screen text would be scrolled away if prompt is multiline.
function __ccdotfiles_promptCommandExitStatus {
  local status=$?
  if [ "$status" != 0 ]; then
    echo -en "\\e[0;41m exit $status \\e[0m "
  fi
}
PROMPT_COMMAND="__ccdotfiles_promptCommandExitStatus; $PROMPT_COMMAND"
