# shellcheck shell=bash
# This is sourced from `.bash_aliases` under interactive bash; see notes there.

export EDITOR=vi # safe fallback, even on BusyBox systems
if command -v vim &>/dev/null; then
  EDITOR=vim
fi

# Increase bash history size.
HISTSIZE=100000
HISTFILESIZE=500000

# Improve `less` paging. This affects all usage, but is motivated by git where
# `FRX` is exported if `LESS` is not set (see `core.pager` on `man git-config`):
#
# - retain 'F' to avoid paging if there is less than one screenful of output
# - add 'I' to enable case-insensitive searches by default
# - retain 'R' allow color codes to work
# - add 'S' to scroll long lines instead of wrapping
# - drop 'X' to enable mouse and touchpad scrolling
export LESS='FIRS'

# Try to use `keychain` as an `ssh-agent` wrapper if we're running under WSL
# without another SSH agent running. If any keys exist in `~/.ssh`, pass them as
# positionals to `keychain`. This is usually already wired up on regular Ubuntu
# by the desktop environment to the login user's keyring.
if [[ -v WSLENV && ! -v SSH_AGENT_PID && ! -v SSH_AUTH_SOCK && -d ~/.ssh ]] &&
  command -v keychain &>/dev/null; then
  # shellcheck source=/dev/null
  find ~/.ssh -name '*.pub' -prune -o -type f -name 'id_*' -print0 |
    xargs -0 -- keychain --agents ssh -- &&
    source "$HOME/.keychain/$HOSTNAME-sh"
fi

# Print status code after each command finishes. This checks `$?`, so it needs
# to be the first thing executed on `$PROMPT_COMMAND`, so try to define this as
# late as possible during shell initialization.
function __ccdotfiles_promptCommandExitStatus {
  local status=$?

  # Display newline after output to guarantee prompt appears on its own even if
  # last output didn't have trailing newline; it's nice to have this here
  # instead of `PS1` in case something prepends onto `PS1` (e.g. `virtualenv`s).
  echo

  if [ "$status" != 0 ]; then
    echo -e "\\e[0;41mexit status $status\\e[0m"
  fi
}
PROMPT_COMMAND="__ccdotfiles_promptCommandExitStatus; $PROMPT_COMMAND"
